fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
param_optimal <- param_optimal$par
param_optimal
## FOC that is lying around is fulfilled!
(G_tilde(mu = param_optimal[1], sigma = param_optimal[2], dataset = dataset)/Nei[1])/(G_tilde(mu = param_optimal[3], sigma = param_optimal[4], dataset = dataset)/Nef[1])
# Parameter Estimate
param_init <- rep(0.05,6)
param_optimal <- optim(
par = param_init,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
param_optimal <- param_optimal$par
param_optimal
# Parameter Estimate
param_init <- rep(0.05,6)
param_optimal <- optim(
par = param_init,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
param_optimal <- param_optimal$par
param_optimal
## FOC that is lying around is fulfilled!
(G_tilde(mu = param_optimal[1], sigma = param_optimal[2], dataset = dataset)/Nei[1])/(G_tilde(mu = param_optimal[3], sigma = param_optimal[4], dataset = dataset)/Nef[1])
## different algorithm converges to the same values
optim(par = param_optimal,fn = LogLikelihood2,method = "L-BFGS-B",
lower = c(-7,0.75,0.0,0.1,0.1,01), upper = rep(10,6), control = list(maxit = 10000, pgtol = 1e-12), ,dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef
)
w_star[count] = min(dataset$wage[dataset$status != 1])
# Parameter Estimate
param_init <- rep(0.05,6)
param_optimal <- optim(
par = param_init,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
param_optimal$par
# Parameter Estimate
param_init <- rep(0.1,6)
param_optimal <- optim(
par = param_init,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
param_optimal$par
# Parameter Estimate
param_init <- rep(0.5,6)
param_optimal <- optim(
par = param_init,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
param_optimal$par
## FOC that is lying around is fulfilled!
(G_tilde(mu = param_optimal[1], sigma = param_optimal[2], dataset = dataset)/Nei[1])/(G_tilde(mu = param_optimal[3], sigma = param_optimal[4], dataset = dataset)/Nef[1])
## FOC that is lying around is fulfilled!
(G_tilde(mu = param_optimal$par[1], sigma = param_optimal$par[2], dataset = dataset)/Nei[1])/(G_tilde(mu = param_optimal$par[3], sigma = param_optimal$par[4], dataset = dataset)/Nef[1])
## define parameters
p <- 0.05
N <- nrow(chile)
N_u <- nrow(chile[chile$status == 1,])
N_f <- nrow(chile[chile$status == 2,])
N_i <- nrow(chile[chile$status == 3,])
# Take the estimate of the reservation wage
w_star <- min(chile$wage[chile$status != 1])
G_tilde <- function(mu, sigma, wage){
return( 1 - plnorm(wage, meanlog = mu, sdlog = sigma, lower.tail = TRUE, log.p = FALSE) )
}
lambda <- function(mu_i,sigma_i,mu_f,sigma_f){
return( ( N_u/(sum(chile$unemp_duration)) )*( 1/(G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) + G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)) ) )
}
eta <- function(lambda,mu_i,sigma_i,mu_f,sigma_f){
return( lambda*( (N/N_i)*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) - G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) ) )
}
LogLikelihood <- function(parameters){
print(parameters)
# Assign parameters
mu_i <- parameters[1]
sigma_i <- parameters[2]
mu_f <- parameters[3]
sigma_f <- parameters[4]
# get values for lambda and eta (concentrated out)
lambda_value <- lambda(mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f  = sigma_f)
eta_value <- eta(lambda = lambda_value, mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f = sigma_f)
# Specify LL
LL <- (
-N*log(1 + lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)*(1/eta_value) +
lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)*(1/eta_value)
) +
# contribution of formally employed
sum(log(dlnorm(x = chile$wage[chile$status == 2], meanlog = mu_f, sdlog = sigma_f))) +
# contribution of informally employed
sum(log(dlnorm(x = chile$wage[chile$status == 3], meanlog = mu_i, sdlog = sigma_i))) +
#
N_f*log(lambda_value/eta_value) +
N_i*log(lambda_value/eta_value) +
N_u*log(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)) -
#
(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star))*sum(chile$unemp_duration)
)
if(sigma_i > 0 & sigma_f > 0 & lambda_value > 0 & eta_value > 0){
return(ifelse(LL == -Inf, 10^100, -LL))
} else{
return(10^100)
}
}
initial_parameters <- c(1,1,1,1)
optimal_parameters <- optim(par = initial_parameters,
fn = LogLikelihood,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
## Load packages
rm(list=ls())
library(tidyverse)
library(stats4)
library(maxLik)
library(alr4)
## Load data
chile <- read.delim(file = "chile.txt", sep = ",", header = FALSE, col.names = c("unemp_duration","wage","status"))
## define parameters
p <- 0.05
N <- nrow(chile)
N_u <- nrow(chile[chile$status == 1,])
N_f <- nrow(chile[chile$status == 2,])
N_i <- nrow(chile[chile$status == 3,])
# Take the estimate of the reservation wage
w_star <- min(chile$wage[chile$status != 1])
G_tilde <- function(mu, sigma, wage){
return( 1 - plnorm(wage, meanlog = mu, sdlog = sigma, lower.tail = TRUE, log.p = FALSE) )
}
lambda <- function(mu_i,sigma_i,mu_f,sigma_f){
return( ( N_u/(sum(chile$unemp_duration)) )*( 1/(G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) + G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)) ) )
}
eta <- function(lambda,mu_i,sigma_i,mu_f,sigma_f){
return( lambda*( (N/N_i)*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) - G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) ) )
}
LogLikelihood <- function(parameters){
print(parameters)
# Assign parameters
mu_i <- parameters[1]
sigma_i <- parameters[2]
mu_f <- parameters[3]
sigma_f <- parameters[4]
# get values for lambda and eta (concentrated out)
lambda_value <- lambda(mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f  = sigma_f)
eta_value <- eta(lambda = lambda_value, mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f = sigma_f)
# Specify LL
LL <- (
-N*log(1 + lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)*(1/eta_value) +
lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)*(1/eta_value)
) +
# contribution of formally employed
sum(log(dlnorm(x = chile$wage[chile$status == 2], meanlog = mu_f, sdlog = sigma_f))) +
# contribution of informally employed
sum(log(dlnorm(x = chile$wage[chile$status == 3], meanlog = mu_i, sdlog = sigma_i))) +
#
N_f*log(lambda_value/eta_value) +
N_i*log(lambda_value/eta_value) +
N_u*log(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)) -
#
(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star))*sum(chile$unemp_duration)
)
if(sigma_i > 0 & sigma_f > 0 & lambda_value > 0 & eta_value > 0){
return(ifelse(LL == -Inf, 10^100, -LL))
} else{
return(10^100)
}
}
initial_parameters <- c(1,1,1,1)
optimal_parameters <- optim(par = initial_parameters,
fn = LogLikelihood,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
# FOC that is lying around is fulfilled!
(G_tilde(mu = optimal_parameters$par[1], sigma = optimal_parameters$par[2], wage = w_star)/N_i)/(G_tilde(mu = optimal_parameters$par[3], sigma = optimal_parameters$par[4], wage = w_star)/N_f)
# Other initial values?
initial_parameters_alt <- c(1,0.4,-4.9,3.1)
optimal_parameters_alt <- optim(par = initial_parameters_alt,
fn = LogLikelihood,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood(parameters)}, start = initial_parameters)
mle_results_alt <- maxLik(logLik = function(parameters){-LogLikelihood(parameters)}, start = optimal_parameters$par)
# But this does not satisfy the FOC!! So choose the other one!!
(G_tilde(mu = mle_results$estimate[1], sigma = mle_results$estimate[2], wage = w_star)/N_i)/(G_tilde(mu = mle_results$estimate[3], sigma = mle_results$estimate[4], wage = w_star)/N_f)
lambda_estimate <- lambda(mu_i = mle_results_alt$estimate[1], sigma_i = mle_results_alt$estimate[2], mu_f = mle_results_alt$estimate[3], sigma_f = mle_results_alt$estimate[4])
eta_estimate <- eta(lambda = lambda_estimate, mu_i = mle_results_alt$estimate[1], sigma_i = mle_results_alt$estimate[2], mu_f = mle_results_alt$estimate[3], sigma_f = mle_results_alt$estimate[4])
param_init2 <- c(-3.6969302,2.7128403,  0.9146251,  0.3604504,0.34,0.05)
param_optimal <- optim(
par = param_init2,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
#############Environment Setting################
################################################
# Load packages
rm(list=ls())
library(tidyverse)
library(stats4)
library(maxLik)
library(alr4)
library(bbmle)
setwd("C:/Users/33678/Desktop/Deeqa_EEE/Empirical methods for policy evaluation/Part 2/Takehome 2-20211227")
source("FunctionLib.R")
chile <- read.delim(file = "chile.txt", sep = ",", header = FALSE, col.names = c("duration","wage","status"))
argentina <- read.delim(file = "argentina.txt", sep = ",", header = FALSE, col.names = c("duration","wage","status"))
colombia  <-read.delim(file = "colombia.txt", sep = ",", header = FALSE, col.names = c("duration","wage","status"))
mexico    <-read.delim(file = "mexico.txt", sep = ",", header = FALSE, col.names = c("duration","wage","status"))
chile$country =1
argentina$country =2
colombia$country =3
mexico$country =4
data <- bind_rows(chile,argentina,colombia,mexico)
Rho <- 0.05
N <- rep(0,max(data$country))
Nu <- rep(0,max(data$country))
Nef <- rep(0,max(data$country))
Nei <- rep(0,max(data$country))
w_star <- rep(0,max(data$country))
count <- 1
dataset <- data %>% filter(country == count)
#Market Stock
N[count] <- nrow(dataset)
Nu[count] <- nrow(dataset[dataset$status == 1,])
Nef[count] <- nrow(dataset[dataset$status == 2,])
Nei[count] <- nrow(dataset[dataset$status == 3,])
w_star[count] = min(dataset$wage[dataset$status != 1])
# Parameter Estimate
param_init <- rep(0.5,6)
param_init2 <- c(-3.6969302,2.7128403,  0.9146251,  0.3604504,0.34,0.05)
param_optimal <- optim(
par = param_init2,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
## FOC that is lying around is fulfilled!
(G_tilde(mu = param_optimal$par[1], sigma = param_optimal$par[2], dataset = dataset)/Nei[1])/(G_tilde(mu = param_optimal$par[3], sigma = param_optimal$par[4], dataset = dataset)/Nef[1])
warnings()
# Other initial values?
initial_parameters_alt <- c(1,0.4,-4.9,3.1,1,1)
optimal_parameters_alt <- optim(par = initial_parameters_alt,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
optimal_parameters_alt <- optim(par = initial_parameters_alt,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12),dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = initial_parameters,dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = initial_parameters_alt,dataset=dataset,count = count ,Nu = Nu,Nei=Nei,Nef=Nef)
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = initial_parameters_alt)
## Load packages
rm(list=ls())
library(tidyverse)
library(stats4)
library(maxLik)
library(alr4)
## Load data
chile <- read.delim(file = "chile.txt", sep = ",", header = FALSE, col.names = c("unemp_duration","wage","status"))
## define parameters
p <- 0.05
N <- nrow(chile)
N_u <- nrow(chile[chile$status == 1,])
N_f <- nrow(chile[chile$status == 2,])
N_i <- nrow(chile[chile$status == 3,])
# Take the estimate of the reservation wage
w_star <- min(chile$wage[chile$status != 1])
G_tilde <- function(mu, sigma, wage){
return( 1 - plnorm(wage, meanlog = mu, sdlog = sigma, lower.tail = TRUE, log.p = FALSE) )
}
lambda <- function(mu_i,sigma_i,mu_f,sigma_f){
return( ( N_u/(sum(chile$unemp_duration)) )*( 1/(G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) + G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)) ) )
}
eta <- function(lambda,mu_i,sigma_i,mu_f,sigma_f){
return( lambda*( (N/N_i)*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) - G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) ) )
}
LogLikelihood <- function(parameters){
print(parameters)
# Assign parameters
mu_i <- parameters[1]
sigma_i <- parameters[2]
mu_f <- parameters[3]
sigma_f <- parameters[4]
# get values for lambda and eta (concentrated out)
lambda_value <- lambda(mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f  = sigma_f)
eta_value <- eta(lambda = lambda_value, mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f = sigma_f)
# Specify LL
LL <- (
-N*log(1 + lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)*(1/eta_value) +
lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)*(1/eta_value)
) +
# contribution of formally employed
sum(log(dlnorm(x = chile$wage[chile$status == 2], meanlog = mu_f, sdlog = sigma_f))) +
# contribution of informally employed
sum(log(dlnorm(x = chile$wage[chile$status == 3], meanlog = mu_i, sdlog = sigma_i))) +
#
N_f*log(lambda_value/eta_value) +
N_i*log(lambda_value/eta_value) +
N_u*log(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)) -
#
(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star))*sum(chile$unemp_duration)
)
if(sigma_i > 0 & sigma_f > 0 & lambda_value > 0 & eta_value > 0){
return(ifelse(LL == -Inf, 10^100, -LL))
} else{
return(10^100)
}
}
if(sigma_i > 0 & sigma_f > 0 & lambda > 0 & eta > 0){
return(ifelse(LL == -Inf, 10^100, -LL))
} else{
return(10^100)
}
LogLikelihood2 <- function(parameters){
print(parameters)
# Assign parameters
mu_i <- parameters[1]
sigma_i <- parameters[2]
mu_f <- parameters[3]
sigma_f <- parameters[4]
lambda <- parameters[5]
eta    <- parameters[6]
#
# get values for lambda and eta
N <- N_u+N_i+N_f
# Specify LL
LL <- (
-N*log(1 + lambda*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)*(1/eta) +
lambda*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)*(1/eta)
) +
# contribution of formally employed
sum(log(dlnorm(x = chile$wage[chile$status == 2], meanlog = mu_f, sdlog = sigma_f))) +
# contribution of informally employed
sum(log(dlnorm(x = chile$wage[chile$status == 3], meanlog = mu_i, sdlog = sigma_i))) +
#
N_f*log(lambda/eta) +
N_i*log(lambda/eta) +
N_u*log(lambda*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)) -
#
(lambda*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star))*sum(chile$unemp_duration)
)
if(sigma_i > 0 & sigma_f > 0 & lambda > 0 & eta > 0){
return(ifelse(LL == -Inf, 10^100, -LL))
} else{
return(10^100)
}
}
initial_parameters <- c(1,1,1,1,1,1)
optimal_parameters <- optim(par = initial_parameters,
fn = LogLikelihood,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
initial_parameters <- rep(0.5,6)
optimal_parameters <- optim(par = initial_parameters,
fn = LogLikelihood,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
optimal_parameters <- optim(par = initial_parameters,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
# different algorithm converges to the same values
optim(par = optimal_parameters$par,fn = LogLikelihood,method = "L-BFGS-B",
lower = c(-7,0.75,0.0,0.1,0,0), upper = c(10,10,10,10,1,1), control = list(maxit = 10000, pgtol = 1e-12)
)
# different algorithm converges to the same values
optim(par = optimal_parameters$par,fn = LogLikelihood,method = "L-BFGS-B",
lower = c(-10,0.75,0.0,0.1,0,0), upper = c(10,10,10,10,1,1), control = list(maxit = 10000, pgtol = 1e-12)
)
# FOC that is lying around is fulfilled!
(G_tilde(mu = optimal_parameters$par[1], sigma = optimal_parameters$par[2], wage = w_star)/N_i)/(G_tilde(mu = optimal_parameters$par[3], sigma = optimal_parameters$par[4], wage = w_star)/N_f)
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = initial_parameters)
mle_results_alt <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = optimal_parameters$par)
# But this does not satisfy the FOC!! So choose the other one!!
(G_tilde(mu = mle_results$estimate[1], sigma = mle_results$estimate[2], wage = w_star)/N_i)/(G_tilde(mu = mle_results$estimate[3], sigma = mle_results$estimate[4], wage = w_star)/N_f)
lambda_estimate <- lambda(mu_i = mle_results_alt$estimate[1], sigma_i = mle_results_alt$estimate[2], mu_f = mle_results_alt$estimate[3], sigma_f = mle_results_alt$estimate[4])
eta_estimate <- eta(lambda = lambda_estimate, mu_i = mle_results_alt$estimate[1], sigma_i = mle_results_alt$estimate[2], mu_f = mle_results_alt$estimate[3], sigma_f = mle_results_alt$estimate[4])
View(mle_results_alt)
3\5
3/5
initial_parameters <- rep(1.3,6)
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = initial_parameters)
eta_estimate <- eta2(lambda = lambda_estimate, mu_i = mle_results_alt$estimate[1], sigma_i = mle_results_alt$estimate[2], mu_f = mle_results_alt$estimate[3], sigma_f = mle_results_alt$estimate[4])
eta2 <- function(lambda,mu_i,sigma_i,mu_f,sigma_f){
return( lambda*( (N/N_f)*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) ) )
}
eta_estimate <- eta2(lambda = lambda_estimate, mu_i = mle_results_alt$estimate[1], sigma_i = mle_results_alt$estimate[2], mu_f = mle_results_alt$estimate[3], sigma_f = mle_results_alt$estimate[4])
## Load packages
rm(list=ls())
library(tidyverse)
library(stats4)
library(maxLik)
library(alr4)
## Load data
chile <- read.delim(file = "chile.txt", sep = ",", header = FALSE, col.names = c("unemp_duration","wage","status"))
## define parameters
p <- 0.05
N <- nrow(chile)
N_u <- nrow(chile[chile$status == 1,])
N_f <- nrow(chile[chile$status == 2,])
N_i <- nrow(chile[chile$status == 3,])
# Take the estimate of the reservation wage
w_star <- min(chile$wage[chile$status != 1])
G_tilde <- function(mu, sigma, wage){
return( 1 - plnorm(wage, meanlog = mu, sdlog = sigma, lower.tail = TRUE, log.p = FALSE) )
}
lambda <- function(mu_i,sigma_i,mu_f,sigma_f){
return( ( N_u/(sum(chile$unemp_duration)) )*( 1/(G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) + G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)) ) )
}
eta <- function(lambda,mu_i,sigma_i,mu_f,sigma_f){
return( lambda*( (N/N_i)*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) - G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) ) )
}
eta2 <- function(lambda,mu_i,sigma_i,mu_f,sigma_f){
return( lambda*( (N/N_f)*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) - G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star) ) )
}
LogLikelihood <- function(parameters){
print(parameters)
# Assign parameters
mu_i <- parameters[1]
sigma_i <- parameters[2]
mu_f <- parameters[3]
sigma_f <- parameters[4]
# get values for lambda and eta (concentrated out)
lambda_value <- lambda(mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f  = sigma_f)
eta_value <- eta(lambda = lambda_value, mu_i = mu_i, sigma_i = sigma_i, mu_f = mu_f, sigma_f = sigma_f)
# Specify LL
LL <- (
-N*log(1 + lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)*(1/eta_value) +
lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)*(1/eta_value)
) +
# contribution of formally employed
sum(log(dlnorm(x = chile$wage[chile$status == 2], meanlog = mu_f, sdlog = sigma_f))) +
# contribution of informally employed
sum(log(dlnorm(x = chile$wage[chile$status == 3], meanlog = mu_i, sdlog = sigma_i))) +
#
N_f*log(lambda_value/eta_value) +
N_i*log(lambda_value/eta_value) +
N_u*log(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)) -
#
(lambda_value*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda_value*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star))*sum(chile$unemp_duration)
)
if(sigma_i > 0 & sigma_f > 0 & lambda_value > 0 & eta_value > 0){
return(ifelse(LL == -Inf, 10^100, -LL))
} else{
return(10^100)
}
}
LogLikelihood2 <- function(parameters){
print(parameters)
# Assign parameters
mu_i <- parameters[1]
sigma_i <- parameters[2]
mu_f <- parameters[3]
sigma_f <- parameters[4]
lambda <- parameters[5]
eta    <- parameters[6]
#
# get values for lambda and eta
N <- N_u+N_i+N_f
# Specify LL
LL <- (
-N*log(1 + lambda*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star)*(1/eta) +
lambda*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)*(1/eta)
) +
# contribution of formally employed
sum(log(dlnorm(x = chile$wage[chile$status == 2], meanlog = mu_f, sdlog = sigma_f))) +
# contribution of informally employed
sum(log(dlnorm(x = chile$wage[chile$status == 3], meanlog = mu_i, sdlog = sigma_i))) +
#
N_f*log(lambda/eta) +
N_i*log(lambda/eta) +
N_u*log(lambda*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star)) -
#
(lambda*G_tilde(mu = mu_f, sigma = sigma_f, wage = w_star) + lambda*G_tilde(mu = mu_i, sigma = sigma_i, wage = w_star))*sum(chile$unemp_duration)
)
if(sigma_i > 0 & sigma_f > 0 & lambda > 0 & eta > 0){
return(ifelse(LL == -Inf, 10^100, -LL))
} else{
return(10^100)
}
}
initial_parameters <- rep(1.3,4)
optimal_parameters <- optim(par = initial_parameters,
fn = LogLikelihood,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
initial_parameters2 <- rep(1.3,6)
optimal_parameters2 <- optim(par = initial_parameters2,
fn = LogLikelihood2,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
# different algorithm converges to the same values
optim(par = optimal_parameters$par,fn = LogLikelihood,method = "L-BFGS-B",
lower = c(-10,0.75,0.0,0.1,0,0), upper = c(10,10,10,10,1,1), control = list(maxit = 10000, pgtol = 1e-12)
)
# different algorithm converges to the same values
optim(par = optimal_parameters$par,fn = LogLikelihood,method = "L-BFGS-B",
lower = c(-10,0.75,0.0,0.1), upper = c(10,10,10,10), control = list(maxit = 10000, pgtol = 1e-12)
)
optim(par = optimal_parameters2$par,fn = LogLikelihood,method = "L-BFGS-B",
lower = c(-10,0.75,0.0,0.1,0,0), upper = c(10,10,10,10,1,1), control = list(maxit = 10000, pgtol = 1e-12)
)
# FOC that is lying around is fulfilled!
(G_tilde(mu = optimal_parameters$par[1], sigma = optimal_parameters$par[2], wage = w_star)/N_i)/(G_tilde(mu = optimal_parameters$par[3], sigma = optimal_parameters$par[4], wage = w_star)/N_f)
(G_tilde(mu = optimal_parameters2$par[1], sigma = optimal_parameters2$par[2], wage = w_star)/N_i)/(G_tilde(mu = optimal_parameters2$par[3], sigma = optimal_parameters2$par[4], wage = w_star)/N_f)
# Other initial values?
initial_parameters_alt <- c(1,0.4,-4.9,3.1)
optimal_parameters_alt <- optim(par = initial_parameters_alt,
fn = LogLikelihood,method = "BFGS",
control = list(maxit = 10000, reltol = 1e-12))
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood(parameters)}, start = initial_parameters)
mle_results_alt <- maxLik(logLik = function(parameters){-LogLikelihood(parameters)}, start = optimal_parameters$par)
mle_results2 <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = initial_parameters)
mle_results_alt2 <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = optimal_parameters$par)
mle_results <- maxLik(logLik = function(parameters){-LogLikelihood(parameters)}, start = initial_parameters)
mle_results_alt <- maxLik(logLik = function(parameters){-LogLikelihood(parameters)}, start = optimal_parameters$par)
mle_results2 <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = initial_parameters2)
mle_results_alt2 <- maxLik(logLik = function(parameters){-LogLikelihood2(parameters)}, start = optimal_parameters2$par)
View(mle_results2)
# But this does not satisfy the FOC!! So choose the other one!!
(G_tilde(mu = mle_results$estimate[1], sigma = mle_results$estimate[2], wage = w_star)/N_i)/(G_tilde(mu = mle_results$estimate[3], sigma = mle_results$estimate[4], wage = w_star)/N_f)
(G_tilde(mu = optimal_parameters2$par[1], sigma = optimal_parameters2$par[2], wage = w_star)/N_i)/(G_tilde(mu = optimal_parameters2$par[3], sigma = optimal_parameters2$par[4], wage = w_star)/N_f)
optimal_parameters2$par
(G_tilde(mu = mle_results2$estimate[1], sigma = mle_results2$estimate[2], wage = w_star)/N_i)/(G_tilde(mu = mle_results2$estimate[3], sigma = mle_results2$estimate[4], wage = w_star)/N_f)
optimal_parameters2$par
mle_results2$estimate
(G_tilde(mu = mle_results_alt2$estimate[1], sigma = mle_results_alt2$estimate[2], wage = w_star)/N_i)/(G_tilde(mu = mle_results_alt2$estimate[3], sigma = mle_results_alt2$estimate[4], wage = w_star)/N_f)
